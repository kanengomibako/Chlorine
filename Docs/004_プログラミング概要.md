# プログラミング概要

### 1. ハードウェア
Chlorineの回路を簡略化した図を示します。

![簡略図](img/004_001_sch.png) 

入力信号は、オーディオコーデックでアナログ→デジタル変換され（ADC）、マイコンへ送られます。マイコンで信号処理し送られたデータは、デジタル→アナログ変換され（DAC）出力されます。このデータ送受信の方式は I2S（Inter-IC Sound）フォーマットと呼ばれるもので、この通信を行うのが SAI ペリフェラルです。

![波形](img/004_001_sig.png) 

機器に入力された音声信号は時間と電圧の関係として表されます。これを一定時間ごとにサンプリング（電圧読み取り）し、データ配列としてコンピュータに取り込みます。このサンプルデータに何らかの処理を施すことで、エフェクトをかけるということになります。

オーディオサンプリングレート44.1kHzの場合は、1秒間に44100個<sup>※</sup>のデータサンプルを送受信します。効率よく処理するため、ある程度まとまったサンプル数で処理を行います。このサンプルの個数がブロックサイズです。（※ 正確には、LchとRchで1組として44100組、88200個）

マイコンからディスプレイへのデータ送信はSPI（Serial Peripheral Interface）、EEPROMのデータ保存・読込はI2C（Inter-Integrated Circuit）と呼ばれる通信方式です。

***

### 2. 動作の流れ

- メインループ
	
	まず main.c の main 関数が実行されますが、その中で各機能の初期化後、mainLoop 関数が繰り返し実行されます。Chlorineでは、ここで主にディスプレイ表示の更新を行っています。
	※ main.c に直接主なコードを書いてもよいのですが、誤って USER CODE 以外の部分に書いてしまうとコード自動生成時に消去されるので、user_main.cpp という別ファイルに分けています。
	
- SAI 割り込み
	
	SAI で常にデータの入出力を行っていますが、ブロックサイズごとに割り込みが起こるようになっています（3. 信号処理詳細 参照）。この割り込み時にエフェクト処理やスイッチ状態の読み取りを行っています。

![メインループ](img/004_002_main.png) 

デュアルコアではないので、同時並行して処理を進めることはできません。基本は信号処理（割り込み）を行い、空いた時間にメインループの処理が進みます。もし信号処理に時間がかかりすぎれば、メインループ側の処理が進まないのでディスプレイ表示の更新がうまくいかないことになります。

***

### 3. 信号処理詳細

SAI用の送受信バッファ配列サイズはブロックサイズの4倍となっています。中身は「Lch前半・後半、Rch前半・後半」で、データの順序はLR交互（L・R・L・R...）ですが、ここではLRで1組として考えます。

データ前半の受信が終わると user_main.cpp にある HAL_SAI_RxHalfCpltCallback 関数が、後半の受信が終わると HAL_SAI_RxCpltCallback 関数が呼び出されます。下図のような流れです。

![SAI](img/004_003_I2S.png) 

例えば音量を上げるエフェクトの場合は、この割り込み内でデータ数値を増加させればいいということになります。

割り込みの間隔は、ブロックサイズ16、サンプリングレート48kHzの場合 16 / 48 = 0.33 ms（ミリ秒）です。処理遅延はこの2倍発生し、さらにオーディオコーデックIC自体の遅延があるため、全体の遅延（レイテンシ）は約1.2msとなっています。

- DMAについて

  DMA（Direct Memory Access）はデータ送受信の繰り返しを自動で行ってくれる便利な機能です。ただしSTM32H7では、DMA対象データの配置先の指定、MPU（Memory Protection Unit）の設定が必要となります。
  
  - 参考ページ → [STM32H7でキャッシュ一貫性を保持したDMA転送(Memory-to-Peripheral)](https://www.keshikan.net/gohantabeyo/?p=563)
  
    ※ MPUの設定は、[マイコンの機能設定](003_マイコンの機能設定.md)で行うことが可能です。

***

### 4. スイッチ

前述の通り、SAI 割り込みは定期的に起こります。スイッチが押されているかどうかの読み取り（HAL_GPIO_ReadPin 関数）も割り込み内で行います。

読み取りはそこまで頻繁に行う必要はないため、割り込み1では左端スイッチ、割り込み2では中央左スイッチ...というように読み取るスイッチを順番に入れ替えています。（フットスイッチはタップテンポの精度に関係してくるため、毎回読み取りを行っています。）

スイッチのチャタリングによる誤検出防止のため、一定時間連続で押されている判定があった場合に処理を行います。判定時間は #define SHORT_PUSH_MSEC 20 といった具合に設定しています。

***

### 5. ロータリーエンコーダ

一般にロータリーエンコーダの出力波形は下図のようになります。

![RE](img/004_005_re.png)

SAI 割り込みのときにHとLを読み取り、4パターンで記録しておきます。

- A: H　B: H → パターン0
- A: L　B: H → パターン1
- A: L　B: L → パターン2
- A: H　B: L → パターン3

そして、前回のパターンから現在のパターンへの変化によって時計回りと反時計回りを判定します。

※ ロータリーエンコーダの種類によってはクリック位置での出力規定が異なるため、別の判定へと修正が必要となる場合があります。

- パターン0からパターン1 または パターン2からパターン3 :  時計回り
- パターン0からパターン3 または パターン2からパターン1 :  反時計回り

***

### 6. データ保存

USBアップデートでフラッシュメモリを書き換えるとなると、ユーザーデータを外部に保存しておく必要があります。そのため、Chlorineでは外部EEPROMを使用しています。データ保存は優先度を高くする必要がないため、メインループ内で処理を行っています。EEPROMは100万回以上書き換えできますが、プログラミングのミスで繰り返し書き込みが発生するような状態が起きると寿命が縮まってしまうため、注意が必要です。

***

### 7. MIDI

MIDIメッセージの受信時に割り込み（HAL_UART_RxCpltCallback 関数）が発生しますが、現状は特に機能を持たせていません。
